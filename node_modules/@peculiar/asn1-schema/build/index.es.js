/**
 * Copyright (c) 2020, Peculiar Ventures, All rights reserved.
 */

import * as asn1 from 'asn1js';
import { Null, fromBER, Integer, Enumerated, BitString, ObjectIdentifier, Boolean, OctetString, BmpString, UniversalString, NumericString, PrintableString, TeletexString, VideotexString, IA5String, GraphicString, VisibleString, GeneralString, CharacterString, UTCTime, GeneralizedTime, Utf8String, Any, Repeated, Set, Sequence, Constructed, Primitive, Choice, compareSchema } from 'asn1js';

const AsnAnyConverter = {
    fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecode,
    toASN: (value) => {
        if (value === null) {
            return new Null();
        }
        const schema = fromBER(value);
        if (schema.result.error) {
            throw new Error(schema.result.error);
        }
        return schema.result;
    },
};
const AsnIntegerConverter = {
    fromASN: (value) => !value.valueBlock.valueDec && value.valueBlock.valueHex.byteLength > 0 ?
        value.valueBlock.toString()
        : value.valueBlock.valueDec,
    toASN: (value) => new Integer({ value }),
};
const AsnEnumeratedConverter = {
    fromASN: (value) => value.valueBlock.valueDec,
    toASN: (value) => new Enumerated({ value }),
};
const AsnIntegerArrayBufferConverter = {
    fromASN: (value) => value.valueBlock.valueHex,
    toASN: (value) => new Integer({ valueHex: value }),
};
const AsnBitStringConverter = {
    fromASN: (value) => value.valueBlock.valueHex,
    toASN: (value) => new BitString({ valueHex: value }),
};
const AsnObjectIdentifierConverter = {
    fromASN: (value) => value.valueBlock.toString(),
    toASN: (value) => new ObjectIdentifier({ value }),
};
const AsnBooleanConverter = {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Boolean({ value }),
};
const AsnOctetStringConverter = {
    fromASN: (value) => value.valueBlock.valueHex,
    toASN: (value) => new OctetString({ valueHex: value }),
};
function createStringConverter(Asn1Type) {
    return {
        fromASN: (value) => value.valueBlock.value,
        toASN: (value) => new Asn1Type({ value }),
    };
}
const AsnUtf8StringConverter = createStringConverter(Utf8String);
const AsnBmpStringConverter = createStringConverter(BmpString);
const AsnUniversalStringConverter = createStringConverter(UniversalString);
const AsnNumericStringConverter = createStringConverter(NumericString);
const AsnPrintableStringConverter = createStringConverter(PrintableString);
const AsnTeletexStringConverter = createStringConverter(TeletexString);
const AsnVideotexStringConverter = createStringConverter(VideotexString);
const AsnIA5StringConverter = createStringConverter(IA5String);
const AsnGraphicStringConverter = createStringConverter(GraphicString);
const AsnVisibleStringConverter = createStringConverter(VisibleString);
const AsnGeneralStringConverter = createStringConverter(GeneralString);
const AsnCharacterStringConverter = createStringConverter(CharacterString);
const AsnUTCTimeConverter = {
    fromASN: (value) => value.toDate(),
    toASN: (value) => new UTCTime({ valueDate: value }),
};
const AsnGeneralizedTimeConverter = {
    fromASN: (value) => value.toDate(),
    toASN: (value) => new GeneralizedTime({ valueDate: value }),
};
const AsnNullConverter = {
    fromASN: (value) => null,
    toASN: (value) => {
        return new Null();
    },
};

var defaultConverters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AsnAnyConverter: AsnAnyConverter,
  AsnIntegerConverter: AsnIntegerConverter,
  AsnEnumeratedConverter: AsnEnumeratedConverter,
  AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,
  AsnBitStringConverter: AsnBitStringConverter,
  AsnObjectIdentifierConverter: AsnObjectIdentifierConverter,
  AsnBooleanConverter: AsnBooleanConverter,
  AsnOctetStringConverter: AsnOctetStringConverter,
  AsnUtf8StringConverter: AsnUtf8StringConverter,
  AsnBmpStringConverter: AsnBmpStringConverter,
  AsnUniversalStringConverter: AsnUniversalStringConverter,
  AsnNumericStringConverter: AsnNumericStringConverter,
  AsnPrintableStringConverter: AsnPrintableStringConverter,
  AsnTeletexStringConverter: AsnTeletexStringConverter,
  AsnVideotexStringConverter: AsnVideotexStringConverter,
  AsnIA5StringConverter: AsnIA5StringConverter,
  AsnGraphicStringConverter: AsnGraphicStringConverter,
  AsnVisibleStringConverter: AsnVisibleStringConverter,
  AsnGeneralStringConverter: AsnGeneralStringConverter,
  AsnCharacterStringConverter: AsnCharacterStringConverter,
  AsnUTCTimeConverter: AsnUTCTimeConverter,
  AsnGeneralizedTimeConverter: AsnGeneralizedTimeConverter,
  AsnNullConverter: AsnNullConverter
});

var AsnTypeTypes;
(function (AsnTypeTypes) {
    AsnTypeTypes[AsnTypeTypes["Sequence"] = 0] = "Sequence";
    AsnTypeTypes[AsnTypeTypes["Set"] = 1] = "Set";
    AsnTypeTypes[AsnTypeTypes["Choice"] = 2] = "Choice";
})(AsnTypeTypes || (AsnTypeTypes = {}));
var AsnPropTypes;
(function (AsnPropTypes) {
    AsnPropTypes[AsnPropTypes["Any"] = 0] = "Any";
    AsnPropTypes[AsnPropTypes["Boolean"] = 1] = "Boolean";
    AsnPropTypes[AsnPropTypes["OctetString"] = 2] = "OctetString";
    AsnPropTypes[AsnPropTypes["BitString"] = 3] = "BitString";
    AsnPropTypes[AsnPropTypes["Integer"] = 4] = "Integer";
    AsnPropTypes[AsnPropTypes["Enumerated"] = 5] = "Enumerated";
    AsnPropTypes[AsnPropTypes["ObjectIdentifier"] = 6] = "ObjectIdentifier";
    AsnPropTypes[AsnPropTypes["Utf8String"] = 7] = "Utf8String";
    AsnPropTypes[AsnPropTypes["BmpString"] = 8] = "BmpString";
    AsnPropTypes[AsnPropTypes["UniversalString"] = 9] = "UniversalString";
    AsnPropTypes[AsnPropTypes["NumericString"] = 10] = "NumericString";
    AsnPropTypes[AsnPropTypes["PrintableString"] = 11] = "PrintableString";
    AsnPropTypes[AsnPropTypes["TeletexString"] = 12] = "TeletexString";
    AsnPropTypes[AsnPropTypes["VideotexString"] = 13] = "VideotexString";
    AsnPropTypes[AsnPropTypes["IA5String"] = 14] = "IA5String";
    AsnPropTypes[AsnPropTypes["GraphicString"] = 15] = "GraphicString";
    AsnPropTypes[AsnPropTypes["VisibleString"] = 16] = "VisibleString";
    AsnPropTypes[AsnPropTypes["GeneralString"] = 17] = "GeneralString";
    AsnPropTypes[AsnPropTypes["CharacterString"] = 18] = "CharacterString";
    AsnPropTypes[AsnPropTypes["UTCTime"] = 19] = "UTCTime";
    AsnPropTypes[AsnPropTypes["GeneralizedTime"] = 20] = "GeneralizedTime";
    AsnPropTypes[AsnPropTypes["DATE"] = 21] = "DATE";
    AsnPropTypes[AsnPropTypes["TimeOfDay"] = 22] = "TimeOfDay";
    AsnPropTypes[AsnPropTypes["DateTime"] = 23] = "DateTime";
    AsnPropTypes[AsnPropTypes["Duration"] = 24] = "Duration";
    AsnPropTypes[AsnPropTypes["TIME"] = 25] = "TIME";
    AsnPropTypes[AsnPropTypes["Null"] = 26] = "Null";
})(AsnPropTypes || (AsnPropTypes = {}));

class AsnSchemaStorage {
    constructor() {
        this.items = new Map();
    }
    has(target) {
        return this.items.has(target);
    }
    get(target) {
        const schema = this.items.get(target);
        if (!schema) {
            throw new Error("Cannot get schema for current target");
        }
        return schema;
    }
    cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
            schema.schema = this.create(target, true);
        }
    }
    createDefault(target) {
        const schema = {
            type: AsnTypeTypes.Sequence,
            items: {},
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
            Object.assign(schema, parentSchema);
            schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
    }
    create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for (const key in schema.items) {
            const item = schema.items[key];
            const name = useNames ? key : "";
            let asn1Item;
            if (typeof (item.type) === "number") {
                const Asn1TypeName = AsnPropTypes[item.type];
                const Asn1Type = asn1[Asn1TypeName];
                if (!Asn1Type) {
                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
                }
                asn1Item = new Asn1Type({ name });
            }
            else {
                asn1Item = new Any({ name });
            }
            const optional = !!item.optional || item.defaultValue !== undefined;
            if (item.repeated) {
                if (typeof item.repeated === "boolean") {
                    asn1Item.name = "";
                    asn1Item = new Repeated({
                        name,
                        value: asn1Item,
                    });
                }
                else {
                    asn1Item.name = "";
                    const Container = item.repeated === "set"
                        ? Set
                        : Sequence;
                    asn1Item = new Container({
                        name: "",
                        value: [
                            new Repeated({
                                name,
                                value: asn1Item,
                            }),
                        ],
                    });
                }
            }
            if (item.context !== null && item.context !== undefined) {
                if (item.implicit) {
                    if (typeof item.type === "number") {
                        const Container = item.repeated
                            ? Constructed
                            : Primitive;
                        asn1Value.push(new Container({
                            name,
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            },
                        }));
                    }
                    else {
                        this.cache(item.type);
                        const isRepeatedString = typeof item.repeated === "string";
                        const value = !isRepeatedString
                            ? this.get(item.type).schema.valueBlock.value
                            : asn1Item.valueBlock.value;
                        asn1Value.push(new Constructed({
                            name: !isRepeatedString ? name : "",
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            },
                            value,
                        }));
                    }
                }
                else {
                    asn1Value.push(new Constructed({
                        optional,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: item.context,
                        },
                        value: [asn1Item],
                    }));
                }
            }
            else {
                asn1Item.optional = optional;
                asn1Value.push(asn1Item);
            }
        }
        switch (schema.type) {
            case AsnTypeTypes.Sequence:
                return new Sequence({ value: asn1Value, name: "" });
            case AsnTypeTypes.Set:
                return new Set({ value: asn1Value, name: "" });
            case AsnTypeTypes.Choice:
                return new Choice({ value: asn1Value, name: "" });
            default:
                throw new Error(`Unsupported ASN1 type in use`);
        }
    }
    set(target, schema) {
        this.items.set(target, schema);
        return this;
    }
    findParentSchema(target) {
        const parent = target.__proto__;
        if (parent) {
            const schema = this.items.get(parent);
            return schema || this.findParentSchema(parent);
        }
        return null;
    }
}

const schemaStorage = new AsnSchemaStorage();

const AsnType = (options) => (target) => {
    const schema = schemaStorage.get(target);
    Object.assign(schema, options);
};
const AsnProp = (options) => (target, propertyKey) => {
    let schema;
    if (!schemaStorage.has(target.constructor)) {
        schema = schemaStorage.createDefault(target.constructor);
        schemaStorage.set(target.constructor, schema);
    }
    else {
        schema = schemaStorage.get(target.constructor);
    }
    const copyOptions = Object.assign({}, options);
    if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const converterName = `Asn${AsnPropTypes[options.type]}Converter`;
        const defaultConverter = defaultConverters[converterName];
        if (!defaultConverter) {
            throw new Error(`Cannot get '${converterName}' for property '${propertyKey}' of ${target.constructor.name}`);
        }
        copyOptions.converter = defaultConverter;
    }
    schema.items[propertyKey] = copyOptions;
};

class AsnSchemaValidationError extends Error {
    constructor() {
        super(...arguments);
        this.schemas = [];
    }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AsnSchemaValidationError: AsnSchemaValidationError
});

function isConvertible(target) {
    if (target && target.prototype) {
        if (target.prototype.toASN && target.prototype.fromASN) {
            return true;
        }
        else {
            return isConvertible(target.prototype);
        }
    }
    else {
        return !!(target && target.toASN && target.fromASN);
    }
}

class AsnParser {
    static parse(data, target) {
        let buf;
        if (data instanceof ArrayBuffer) {
            buf = data;
        }
        else if (typeof Buffer !== undefined && Buffer.isBuffer(data)) {
            buf = new Uint8Array(data).buffer;
        }
        else if (ArrayBuffer.isView(data)) {
            buf = data.buffer;
        }
        else {
            throw new TypeError("Wrong type of 'data' argument");
        }
        const asn1Parsed = fromBER(buf);
        if (asn1Parsed.result.error) {
            throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
    }
    static fromASN(asn1Schema, target) {
        try {
            if (isConvertible(target)) {
                const value = new target();
                return value.fromASN(asn1Schema);
            }
            const schema = schemaStorage.get(target);
            schemaStorage.cache(target);
            let targetSchema = schema.schema;
            if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
                targetSchema = new Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: asn1Schema.idBlock.tagNumber,
                    },
                    value: schema.schema.valueBlock.value,
                });
                for (const key in schema.items) {
                    delete asn1Schema[key];
                }
            }
            const asn1ComparedSchema = compareSchema(asn1Schema, asn1Schema, targetSchema);
            if (!asn1ComparedSchema.verified) {
                throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
            }
            const res = new target();
            for (const key in schema.items) {
                if (!asn1Schema[key]) {
                    continue;
                }
                const schemaItem = schema.items[key];
                if (typeof (schemaItem.type) === "number") {
                    const converter = schemaItem.converter;
                    if (!converter) {
                        throw new Error("Converter is empty");
                    }
                    if (schemaItem.repeated) {
                        if (schemaItem.implicit && typeof schemaItem.repeated === "string") {
                            const Container = schemaItem.repeated === "sequence"
                                ? Sequence
                                : Set;
                            const newItem = new Container();
                            newItem.valueBlock = asn1Schema[key].valueBlock;
                            const value = fromBER(newItem.toBER(false)).result.valueBlock.value;
                            res[key] = Array.from(value, (element) => converter.fromASN(element));
                        }
                        else {
                            res[key] = Array.from(asn1Schema[key], (element) => converter.fromASN(element));
                        }
                    }
                    else {
                        let value = asn1Schema[key];
                        if (schemaItem.implicit) {
                            const Asn1TypeName = AsnPropTypes[schemaItem.type];
                            const Asn1Type = asn1[Asn1TypeName];
                            if (!Asn1Type) {
                                throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                            }
                            const newItem = new Asn1Type();
                            newItem.valueBlock = value.valueBlock;
                            value = fromBER(newItem.toBER(false)).result;
                        }
                        res[key] = converter.fromASN(value);
                    }
                }
                else {
                    if (schemaItem.repeated) {
                        res[key] = Array.from(asn1Schema[key], (element) => this.fromASN(element, schemaItem.type));
                    }
                    else {
                        res[key] = this.fromASN(asn1Schema[key], schemaItem.type);
                    }
                }
            }
            return res;
        }
        catch (error) {
            if (error instanceof AsnSchemaValidationError) {
                error.schemas.push(target.name);
            }
            throw error;
        }
    }
}

class AsnSerializer {
    static serialize(obj) {
        return this.toASN(obj).toBER(false);
    }
    static toASN(obj) {
        if (obj && isConvertible(obj.constructor)) {
            return obj.toASN();
        }
        const target = obj.constructor;
        const schema = schemaStorage.get(target);
        schemaStorage.cache(target);
        let asn1Value = [];
        for (const key in schema.items) {
            const item = schema.items[key];
            const objProp = obj[key];
            if (objProp === undefined || item.defaultValue === objProp) {
                continue;
            }
            let asn1Item;
            if (typeof (item.type) === "number") {
                const converter = item.converter;
                if (!converter) {
                    throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[item.type]} in schema '${target.name}'`);
                }
                if (item.repeated) {
                    const items = Array.from(objProp, (element) => converter.toASN(element));
                    if (typeof item.repeated === "boolean") {
                        asn1Item = items;
                    }
                    else {
                        const Container = item.repeated === "sequence"
                            ? Sequence
                            : Set;
                        asn1Item = new Container({
                            value: items,
                        });
                    }
                }
                else {
                    asn1Item = converter.toASN(objProp);
                }
            }
            else {
                if (item.repeated) {
                    const items = Array.from(objProp, (element) => this.toASN(element));
                    if (typeof item.repeated === "boolean") {
                        asn1Item = items;
                    }
                    else {
                        const Container = item.repeated === "sequence"
                            ? Sequence
                            : Set;
                        asn1Item = new Container({
                            value: items,
                        });
                    }
                }
                else {
                    asn1Item = this.toASN(objProp);
                }
            }
            if (item.context !== null && item.context !== undefined) {
                if (item.implicit) {
                    if (!item.repeated && typeof item.type === "number") {
                        const value = {};
                        value.valueHex = asn1Item.valueBlock.toBER();
                        asn1Value.push(new Primitive(Object.assign({ optional: item.optional, idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            } }, value)));
                    }
                    else {
                        asn1Value.push(new Constructed({
                            optional: item.optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context,
                            },
                            value: asn1Item.valueBlock.value,
                        }));
                    }
                }
                else {
                    asn1Value.push(new Constructed({
                        optional: item.optional,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: item.context,
                        },
                        value: [asn1Item],
                    }));
                }
            }
            else if (item.repeated) {
                asn1Value = asn1Value.concat(asn1Item);
            }
            else {
                asn1Value.push(asn1Item);
            }
        }
        let asnSchema;
        switch (schema.type) {
            case AsnTypeTypes.Sequence:
                asnSchema = new Sequence({ value: asn1Value });
                break;
            case AsnTypeTypes.Set:
                asnSchema = new Set({ value: asn1Value });
                break;
            case AsnTypeTypes.Choice:
                if (!asn1Value[0]) {
                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
                }
                asnSchema = asn1Value[0];
                break;
        }
        return asnSchema;
    }
}

export { AsnAnyConverter, AsnBitStringConverter, AsnBmpStringConverter, AsnBooleanConverter, AsnCharacterStringConverter, AsnEnumeratedConverter, AsnGeneralStringConverter, AsnGeneralizedTimeConverter, AsnGraphicStringConverter, AsnIA5StringConverter, AsnIntegerArrayBufferConverter, AsnIntegerConverter, AsnNullConverter, AsnNumericStringConverter, AsnObjectIdentifierConverter, AsnOctetStringConverter, AsnParser, AsnPrintableStringConverter, AsnProp, AsnPropTypes, AsnSerializer, AsnTeletexStringConverter, AsnType, AsnTypeTypes, AsnUTCTimeConverter, AsnUniversalStringConverter, AsnUtf8StringConverter, AsnVideotexStringConverter, AsnVisibleStringConverter, index as errors };
